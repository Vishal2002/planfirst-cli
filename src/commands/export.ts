import path from 'path';
import { ExportOptions, Plan } from '../types';
import { logger } from '../utils/logger';
import { exists, readJSON, readFile, writeFile } from '../utils/fileSystem';
import chalk from 'chalk';

/**
 * Export a plan for coding agents
 */
export async function exportCommand(
  planId: string,
  options: ExportOptions
): Promise<void> {
  const rootPath = process.cwd();
  const configPath = path.join(rootPath, '.planfirst', 'config.json');

  logger.section('Exporting Plan');

  // Check if initialized
  if (!(await exists(configPath))) {
    logger.error('PlanFirst is not initialized in this directory');
    logger.info('Run: planfirst init');
    process.exit(1);
  }

  const config = await readJSON(configPath);
  const plansDir = config.plansDirectory;
  
  // Load plan
  const planPath = path.join(plansDir, `${planId}.json`);
  const planMarkdownPath = path.join(plansDir, `${planId}.md`);
  
  if (!(await exists(planPath))) {
    logger.error(`Plan not found: ${planId}`);
    logger.info('Use: planfirst list - to see all plans');
    process.exit(1);
  }

  try {
    const plan: Plan = await readJSON(planPath);
    let exportContent = '';
    let outputPath = '';

    // Determine output path
    if (options.output) {
      outputPath = options.output;
    } else {
      const ext = options.format === 'json' ? 'json' : 'md';
      outputPath = path.join(plansDir, `${planId}-export.${ext}`);
    }

    // Format content based on format
    switch (options.format) {
      case 'json':
        exportContent = JSON.stringify(plan, null, 2);
        break;
      
      case 'cursor':
        exportContent = await formatForCursor(plan, planMarkdownPath);
        break;
      
      case 'markdown':
      default:
        // Read the original markdown
        if (await exists(planMarkdownPath)) {
          exportContent = await readFile(planMarkdownPath);
        } else {
          exportContent = formatAsMarkdown(plan);
        }
        break;
    }

    // Filter by phase if specified
    if (options.phase) {
      const phaseNum = parseInt(options.phase.toString());
      if (phaseNum > 0 && phaseNum <= plan.phases.length) {
        const phase = plan.phases[phaseNum - 1];
        exportContent = formatPhaseOnly(phase, options.format);
      } else {
        logger.error(`Invalid phase number: ${phaseNum}`);
        logger.info(`Plan has ${plan.phases.length} phases`);
        process.exit(1);
      }
    }

    // Write export
    await writeFile(outputPath, exportContent);

    logger.newline();
    console.log(chalk.cyan('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
    console.log(chalk.cyan('â•‘') + chalk.bold.white('         ðŸ“„  Plan Exported Successfully!  ðŸ“„            ') + chalk.cyan('â•‘'));
    console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
    logger.newline();

    logger.subsection('Export Details');
    logger.keyValue('Plan ID', planId, 1);
    logger.keyValue('Format', options.format, 1);
    logger.keyValue('Output', outputPath, 1);
    if (options.phase) {
      logger.keyValue('Phase', options.phase.toString(), 1);
    }
    logger.newline();

    logger.subsection('Next Steps');
    logger.item(`View the export: cat ${outputPath}`, 1);
    logger.item('Copy this file to your coding agent (Cursor, Claude Code, etc.)', 1);
    logger.item(`After implementation: planfirst verify ${planId}`, 1);
    logger.newline();

  } catch (error) {
    logger.error('Export failed', error);
    throw error;
  }
}

/**
 * Format plan for Cursor AI
 */
async function formatForCursor(plan: Plan, markdownPath: string): Promise<string> {
  let content = `# Implementation Plan: ${plan.title}\n\n`;
  content += `**Generated by PlanFirst CLI**\n\n`;
  content += `## Overview\n${plan.description}\n\n`;
  content += `## Metadata\n`;
  content += `- Complexity: ${plan.metadata.estimatedComplexity}\n`;
  content += `- Estimated Time: ${plan.metadata.estimatedTime}\n`;
  content += `- Files to modify: ${plan.metadata.filesAffected.length}\n\n`;

  // Add original plan content
  if (await exists(markdownPath)) {
    const originalPlan = await readFile(markdownPath);
    content += `## Detailed Plan\n\n${originalPlan}\n\n`;
  }

  content += `## Implementation Checklist\n\n`;
  
  plan.phases.forEach((phase, idx) => {
    content += `### Phase ${idx + 1}: ${phase.name}\n\n`;
    phase.tasks.forEach(task => {
      content += `- [ ] ${task.description}\n`;
      content += `  - File: \`${task.file}\`\n`;
      content += `  - Action: ${task.type}\n`;
      if (task.reasoning) {
        content += `  - Reason: ${task.reasoning}\n`;
      }
      content += `\n`;
    });
  });

  return content;
}

/**
 * Format plan as markdown
 */
function formatAsMarkdown(plan: Plan): string {
  let content = `# ${plan.title}\n\n`;
  content += `${plan.description}\n\n`;
  
  content += `## Plan Information\n\n`;
  content += `- **Plan ID**: ${plan.id}\n`;
  content += `- **Created**: ${new Date(plan.timestamp).toLocaleString()}\n`;
  content += `- **Complexity**: ${plan.metadata.estimatedComplexity}\n`;
  content += `- **Estimated Time**: ${plan.metadata.estimatedTime}\n`;
  content += `- **Status**: ${plan.status}\n\n`;

  content += `## Phases\n\n`;
  
  plan.phases.forEach((phase, idx) => {
    content += `### Phase ${idx + 1}: ${phase.name}\n\n`;
    content += `${phase.description}\n\n`;
    
    content += `**Tasks:**\n\n`;
    phase.tasks.forEach((task, tidx) => {
      content += `${tidx + 1}. **${task.description}**\n`;
      content += `   - File: \`${task.file}\`\n`;
      content += `   - Type: ${task.type}\n`;
      content += `   - Reasoning: ${task.reasoning}\n\n`;
    });
  });

  if (plan.metadata.filesAffected.length > 0) {
    content += `## Files to be Modified\n\n`;
    plan.metadata.filesAffected.forEach(file => {
      content += `- \`${file}\`\n`;
    });
    content += `\n`;
  }

  return content;
}

/**
 * Format single phase
 */
function formatPhaseOnly(phase: any, format: string): string {
  let content = `# ${phase.name}\n\n`;
  content += `${phase.description}\n\n`;
  content += `## Tasks\n\n`;
  
  phase.tasks.forEach((task: any, idx: number) => {
    content += `${idx + 1}. **${task.description}**\n`;
    content += `   - File: \`${task.file}\`\n`;
    content += `   - Type: ${task.type}\n`;
    content += `   - Reasoning: ${task.reasoning}\n\n`;
  });

  return content;
}